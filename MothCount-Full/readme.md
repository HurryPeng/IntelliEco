**This Directory is initialized by W-Hsu**

# MothCount-Release *version 1*

## 流程概述[^1]
1. 读取源图片，并执行非空判断、纵横转换以及压缩图片操作。
1. 计算上一步处理后图片的基本信息：行列数，面积[^2]。并将其转换至HSV颜色空间。
1. 进行**颜色阈值计算**、处理操作，处于阈值内的颜色设定为白色，其它颜色设定为黑色。目的是将粘虫板转换为白色，将飞蛾转换为黑色。
1. 定义基于**广度优先搜索**算法的连续块[^3]搜索方法，用于搜索黑白二值图像中所有的连续块。利用list容器存储连续块。
1. 扩增白色区域。
1. **画出边界线**，目的是将粘虫板边缘的黑色飞蛾连续块与外部黑色区域连续块分隔。
1. 首次搜索所有存在的连续块，擦除较小的连续块，并利用**APR2值**[^4]特征擦除树枝类似连续块。
1. 缩减白色区域。
1. 再次搜索所有存在的连续块，并在控制台上打印各连续块的信息，擦除较小的连续块。
1. 再次搜索所有存在的连续块，计算粘虫板的面积（最大的白色块+飞蛾黑色块）。
1. 根据统计学方法得出**粘虫板与单个飞蛾面积的系数比例**，再利用粘虫板的面积与系数比例算出单个飞蛾的面积。
1. 算出**大小合适的黑色块**面积之和（排除了外部较大黑色区域），作为飞蛾面积之和。
1. 最终由飞蛾总面积与单个飞蛾的面积相除，得到飞蛾总数。

[^1]: 加粗的部分为程序的“核心算法”或“规律”。
[^2]: 不经说明，本文中提到的“面积”即为“以像素为单位的面积”。
[^3]: 敬请参见本文“程序部分”中“类对象”的“Block 类”。
[^4]: APR2值为“Area Per Radius^2”的简写，即连续块的面积与半径平方的比值。为了方便比较，再乘以系数100。

## 程序部分
### 头文件与命名空间：
main.cpp使用以下头文件：
```
    <opencv2/core.hpp>
    <opencv2/imgcodecs.hpp
    <opencv2/imgproc.hpp>
    <opencv2/highgui.hpp>
    <iostream>
    <list>
    <queue>
    <deque>
```
以及为本项目编写的：
    `"DrawContour.hpp"`
    要查看其说明，敬请参见"readme.DrawContours.md"

main.cpp使用命名空间
```
    cv
    std
```

### 类对象
Block类：
`class Block`
含义：黑白二值图像上的一块相连的，且颜色相同的区域，称作“连续块”。
    成员：
    `deque<Point> pixels`
        存储该连续块每个像素坐标。
    `bool white`
        描述该连续块的黑白性。若该连续块是白色，则此值为真，反之则假。
    `Point cog`
        存储该连续块的重心坐标。
    `int r`
        存储该连续块重心到边界的最远距离，称作“半径”。
    `Block()`
        返回一个空
    `void add (Point p)`
        将点p加入连续块中。
    `long area() const`
        获取该连续块所占像素数（面积）
    `Point getCog()`
        获取该连续块的重心坐标。
        方法：遍历连续块中所有点，分别将横、纵坐标值求和，再分别取算术平均值，得到的结果即为重心坐标。
    `int getR()`
        获取该连续块的半径。
        方法：遍历连续块中所有点，计算其到重心的距离，最大者即为半径。
    `int getAPR2()`
        获取该连续块的APR2值
    `void erase()`
        抹除该连续块。即将本连续块的颜色值改变为与自己相反的颜色。
        
### 核心算法
1. **颜色阈值计算**
   目的：计算二值化处理图片时的H阈值。
   代码
```
int hSum1 = 0, sSum1 = 0, vSum1 = 0;
int area1 = 0;
for (int i = 0; i < col * 3; i += 3) for (int j = 0; j < row; j++)
{
    if (get(i, j) >= 20 && get(i, j) <= 50)
    {
        area1++;
        hSum1 += get(i, j);
        sSum1 += get(i + 1, j);
        vSum1 += get(i + 2, j);
    }
}
```
   说明：
   阈值计算选用H值20至50之间的点（偏黄色）的H值作为原始数据，进行取算术平均值操作，求得适合该图像的H阈值。

1. **广度优先搜索与连续块搜索**
    目的：搜索或更新黑白二值图片中的连续块，将所有连续块存储至list容器中。
    代码
```
auto bfs = [get, col, row](int x, int y)
	{
		if (Counted[x][y]) return Block();
		Block block;
		block.white = (get(x, y) == 255 ? true : false);
		queue<Point> q;
		q.emplace(x, y);
		while (!q.empty())
		{
			Point p = q.front();
			q.pop();
			if (Counted[p.x][p.y]) continue;
			Counted[p.x][p.y] = true;
			block.add(p);
			if (p.x - 1 >= 0) if (get(p.x - 1, p.y) == get(x, y)) q.emplace(p.x - 1, p.y);
			if (p.x + 1 < col) if (get(p.x + 1, p.y) == get(x, y)) q.emplace(p.x + 1, p.y);
			if (p.y - 1 >= 0) if (get(p.x, p.y - 1) == get(x, y)) q.emplace(p.x, p.y - 1);
			if (p.y + 1 < row) if (get(p.x, p.y + 1) == get(x, y)) q.emplace(p.x, p.y + 1);
		}
		return block;
	};
```
   说明：算法函数bfs的参数(x,y)构成一个初始点，由初始点开始向上、下、左、右分别搜索是否有黑白性质相同的点。若有，则把搜寻到的点加入待搜名单中，再从待搜名单中取出点继续进行上述搜索。若待搜名单为空，则搜索结束。
   该算法需要判断点是否已经被查找过，避免重复查找。程序已经定义全局布尔数组：
   `bool Counted[2001][2001] = { false }`
   当连续块被找到，其中所有点都应已被标记为true。

1. **画出边界线**
    本功能由`"DrawContour.hpp"`提供，敬请参见"readme.DrawContours.md"。

### 规律
1. **利用APR2值特征擦除树枝类似连续块**
    经过统计学分析，单个飞蛾的APR2值落在100到200之间。而树枝的APR2一般不大于50。
1. **粘虫板与单个飞蛾面积的系数比例**
    通过利用统计学方法分析多张图片中各连续块的大小信息，我们得到飞蛾的面积与粘虫板面积的比例约为0.0023。
1. **大小合适的黑色块**
    由于飞蛾存在重叠现象，因此不能武断地将面积比单个飞蛾大的部分排除。
    通过统计学分析，我们得到最大黑色块的面积不超过7000。


